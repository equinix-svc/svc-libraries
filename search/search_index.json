{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SVC Python Libraries","text":"<p>A collection of internal Python libraries used by the SVC team for network automation and system synchronization. This repository is organized as a monorepo and managed using Poetry.</p>"},{"location":"#available-packages","title":"\ud83d\udce6 Available Packages","text":"<p>This repository contains three standalone libraries:</p> Package Description svc_juniper_lib Helpers for interacting with Juniper devices svc_netbox_lib Utilities for interacting with NetBox (REST API wrappers, data fetchers). svc_synchronize_lib Higher-level sync logic combining Juniper + NetBox operations. <p>Each library is published as an installable Python package.</p>"},{"location":"#repository-structure","title":"\ud83e\uddf1 Repository Structure","text":"<pre><code>svc-libraries/\n\u2502\n\u251c\u2500\u2500 packages/\n\u2502 \u251c\u2500\u2500 svc_juniper_lib/\n\u2502 \u2502 \u2514\u2500\u2500 src/svc_juniper_lib/\n\u2502 \u2502\n\u2502 \u251c\u2500\u2500 svc_netbox_lib/\n\u2502 \u2502 \u2514\u2500\u2500 src/svc_netbox_lib/\n\n\u2502 \u2514\u2500\u2500 svc_synchronize_lib/\n\u2502 \u2514\u2500\u2500 src/svc_synchronize_lib/\n\u2502\n\u251c\u2500\u2500 docs/ # MkDocs documentation (generated online)\n\u251c\u2500\u2500 mkdocs.yml # Documentation configuration\n\u2514\u2500\u2500 pyproject.toml # Monorepo workspace config\n</code></pre>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>You can install any library directly from GitHub:</p>"},{"location":"#install-netbox-lib","title":"Install NetBox lib","text":"<pre><code>pip install \"git+https://git@github.com/equinix-svc/svc-libraries.git#subdirectory=packages/svc_netbox_lib\"\n</code></pre>"},{"location":"#install-juniper-lib","title":"Install Juniper lib","text":"<pre><code>pip install \"git+https://git@github.com/equinix-sv/svc-libraries.git#subdirectory=packages/svc_juniper_lib\"\n</code></pre>"},{"location":"#install-synchronize-lib","title":"Install Synchronize lib","text":"<pre><code>pip install \"git+https://git@github.com/equinix-sv/svc-libraries.git#subdirectory=packages/svc_synchronize_lib\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from svc_netbox_lib.netbox import X\nfrom svc_juniper_lib.juniper import Y\nfrom svc_synchronize_lib.synchronize import Z\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full API documentation is available at:</p> <p>https://equinix-svc.github.io/svc-libraries</p> <p>Documentation is auto-generated using <code>mkdocs-material</code> + <code>mkdocstrings</code>. Source files live under <code>docs/</code>.</p>"},{"location":"juniper/","title":"Juniper Library","text":""},{"location":"juniper/#svc_juniper_lib.juniper","title":"<code>svc_juniper_lib.juniper</code>","text":""},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex2200_version","title":"<code>juniper_get_ex2200_version(ip_address, username, password)</code>","text":"<p>Return the software version string reported by an EX2200 device.</p> <p>The function extracts the version substring contained in square brackets, if present.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex2200_version--parameters","title":"Parameters","text":"<p>ip_address : str     Hostname or IP of the EX2200 device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex2200_version--returns","title":"Returns","text":"<p>str     Extracted version string (contents inside brackets if present) or the raw version string.</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_ex2200_version(ip_address,username,password):\n    \"\"\"Return the software version string reported by an EX2200 device.\n\n    The function extracts the version substring contained in square brackets, if present.\n\n    Parameters\n    ----------\n    ip_address : str\n        Hostname or IP of the EX2200 device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    str\n        Extracted version string (contents inside brackets if present) or the raw version string.\n    \"\"\"\n    dev = Device(host=ip_address, user=username, password=password, port='22',timeout=300).open()\n    ex_version = EX2200Version(dev)\n    ex_version.get()\n\n    results=ex_version[0].version\n    #extract only the version\n    only_version = results[results.find('[')+1:results.find(']')]\n    return only_version\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex3400_version","title":"<code>juniper_get_ex3400_version(fqdn, username, password)</code>","text":"<p>Return the software version string reported by an EX3400 device.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex3400_version--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the EX3400 device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex3400_version--returns","title":"Returns","text":"<p>str     Version string as returned by the EX3400 device model.</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_ex3400_version(fqdn, username, password):\n    \"\"\"Return the software version string reported by an EX3400 device.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the EX3400 device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    str\n        Version string as returned by the EX3400 device model.\n    \"\"\"\n    dev = Device(host=fqdn, user=username, password=password, port='22',timeout=300).open()\n    ex_version = EX3400Version(dev)\n    ex_version.get()\n\n    results=ex_version[0].version\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex_interfaces","title":"<code>juniper_get_ex_interfaces(fqdn, username, password)</code>","text":"<p>Return EX/QFX-EX interface metadata including description, speed, and fiber/copper type.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex_interfaces--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the EX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_ex_interfaces--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of interface name to a dict containing:     - 'description' (str)     - 'speed' (str)     - 'type' (str) one of 'SMF', 'MMF', 'copper', or 'lag'</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_ex_interfaces(fqdn, username, password):\n    \"\"\"Return EX/QFX-EX interface metadata including description, speed, and fiber/copper type.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the EX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of interface name to a dict containing:\n        - 'description' (str)\n        - 'speed' (str)\n        - 'type' (str) one of 'SMF', 'MMF', 'copper', or 'lag'\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22',timeout=300) as dev:\n        ports = QFXEXPhysicalTable(dev)\n        sfp = QFXEXChassisHardware(dev)\n        ports.get()\n        sfp.get()\n\n    # create a dictionary of interface names with another dictionary with port description, sfp type and speed\n    results = {}\n    for key,value in ports.items():\n        if value[0][1] == None:\n            results.update({key: {'description': ''}})\n        else:\n            results.update({key:{'description':value[0][1]}})\n        #change 1000mbps to 1Gbps to match Netbox tag\n        if value[1][1] == '1000mbps' or value[1][1] == '1000 Mbps' or value[1][1] == 'Auto':\n            results[key]['speed'] = '1Gbps'\n            results[key]['type'] = 'copper'\n        elif value[1][1] == '100mbps':\n            results[key]['speed'] = '100mbps'\n            results[key]['type'] = 'copper'\n        else:\n            results[key]['speed'] = value[1][1]\n\n        # for ae interfaces set type to lag\n        if 'ae' in key:\n            results[key]['type'] = 'lag'\n\n    for key,value in sfp.items():\n        #construct interface from fpc, pic, port and sfp description\n        if '10G' in value[1][1]:\n            type = 'xe-'\n        else:\n            type = 'ge-'\n        fpc = value[4][1].replace('FPC ', '')\n        pic = value[3][1].replace('PIC ', '')\n        port = key.replace('Xcvr ','')\n\n        #match chassis hardware description to netbox tags\n        if int(port) &lt; 48:\n            try:\n                if value[1][1] == 'SFP+-10G-LR' or value[1][1] == 'SFP-LX10' or value[1][1] == 'QSFP+-40G-LR4':\n                    results[type+fpc+'/'+pic+'/'+port]['type']='SMF'\n                elif value[1][1] == 'SFP+-10G-SR' or value[1][1] == 'SFP-SX':\n                    results[type + fpc + '/' + pic + '/' + port]['type'] = 'MMF'\n                else:\n                    results[type + fpc + '/' + pic + '/' + port]['type'] = 'copper'\n            except:\n                pass\n\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_instance","title":"<code>juniper_get_instance(fqdn, site, username, password)</code>","text":"<p>Retrieve routing-instance (VRF) information from an MX device.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_instance--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the MX device. site : str     Site label used when constructing certain route-distinguisher strings for special instances. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_instance--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of routing-instance name to a dict with keys:     - 'instance_type' (str)     - 'route_distinguisher' (str or None)     - 'instance_interface' (list[str])</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_instance(fqdn, site, username, password):\n    \"\"\"Retrieve routing-instance (VRF) information from an MX device.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the MX device.\n    site : str\n        Site label used when constructing certain route-distinguisher strings for special instances.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of routing-instance name to a dict with keys:\n        - 'instance_type' (str)\n        - 'route_distinguisher' (str or None)\n        - 'instance_interface' (list[str])\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22',timeout=300) as dev:\n        instance=MXRouteInstance(dev)\n        instance.get()\n\n    results={}\n    for key,value in instance.items():\n        if '__' not in key and 'master' not in key and 'junos' not in key:\n            if value[1][1]=='0:0':\n                results.update({key: {'instance_type': value[0][1], 'route_distinguisher': None,\n                                  'instance_interface': value[2][1]}})\n            elif key == \"RI-VRF-Internet-2\":\n                if value[1][1] == None:\n                    results.update({site.upper() + ' ' + key: {'instance_type': value[0][1], 'route_distinguisher':value[1][1],\n                                                                   'instance_interface': value[2][1]}})\n                else:\n                    results.update({site.upper()+' '+key: {'instance_type': value[0][1], 'route_distinguisher': site +' '+value[1][1],\n                                                               'instance_interface': value[2][1]}})\n\n            else:\n                if value[1][1] == None:\n                    results.update({key: {'instance_type': value[0][1], 'route_distinguisher': value[1][1],\n                                          'instance_interface': value[2][1]}})\n                else:\n                    results.update(\n                        {key: {'instance_type': value[0][1], 'route_distinguisher': site + ' ' + value[1][1],\n                               'instance_interface': value[2][1]}})\n\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interface_vlans_dictionary","title":"<code>juniper_get_mx_interface_vlans_dictionary(fqdn, username, password)</code>","text":"<p>Return a mapping of MX subinterface VLAN IDs to their configured descriptions.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interface_vlans_dictionary--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the MX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interface_vlans_dictionary--returns","title":"Returns","text":"<p>dict[int, str]     Mapping of VLAN ID to description. If an interface has no description the value will be 'None'.</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_mx_interface_vlans_dictionary(fqdn, username, password):\n    \"\"\"Return a mapping of MX subinterface VLAN IDs to their configured descriptions.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the MX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[int, str]\n        Mapping of VLAN ID to description. If an interface has no description the value will be 'None'.\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22', timeout=300) as dev:\n        ports = MXLogicalTable(dev)\n        ports.get()\n\n    # create a dictionary of subinterfaces/vlans (key) and the description (value)\n    results = {}\n\n    for key, value in ports.items():\n        subinterface = key.split('.')\n\n        if 'xe' in subinterface[0] or 'ge' in subinterface[0] or 'ae' in subinterface[0] or 'ms' in subinterface[0]:\n            if 1 &lt; int(subinterface[1]) &lt; 4095:\n                if value[0][1]:\n                    results.update({int(subinterface[1]): value[0][1]})\n                else:\n                    results.update({int(subinterface[1]): 'None'})\n\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interfaces","title":"<code>juniper_get_mx_interfaces(fqdn, username, password)</code>","text":"<p>Return MX interface metadata including description, speed, and fiber/copper type.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interfaces--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the MX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_interfaces--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of interface name to a dict containing:     - 'description' (str)     - 'speed' (str)     - 'type' (str) one of 'SMF', 'MMF', 'copper', 'lag', or 'No SFP'</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_mx_interfaces(fqdn, username, password):\n    \"\"\"Return MX interface metadata including description, speed, and fiber/copper type.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the MX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of interface name to a dict containing:\n        - 'description' (str)\n        - 'speed' (str)\n        - 'type' (str) one of 'SMF', 'MMF', 'copper', 'lag', or 'No SFP'\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22',timeout=300) as dev:\n        ports = MXPhysicalTable(dev)\n        sfp = MXChassisHardware(dev)\n        ports.get()\n        sfp.get()\n    # create a dictionary of interface names with another dictionary with port description, sfp type and speed\n    results = {}\n    for key, value in ports.items():\n        if value[0][1] is None:\n            results.update({key: {'description': ''}})\n        else:\n            results.update({key: {'description': value[0][1]}})\n\n        # change 1000mbps to 1Gbps to match Netbox tag\n        if value[1][1] == '1000mbps' or value[1][1] == '1000 Mbps':\n            results[key]['speed'] = '1Gbps'\n            results[key]['type'] = 'copper'\n        else:\n            results[key]['speed'] = value[1][1]\n\n        # for ae interfaces set type to lag, anything else set to None\n        if 'ae' in key:\n            results[key]['type'] = 'lag'\n        elif 'ge' in key:\n            results[key]['type'] = 'copper'\n        else:\n            results[key]['type'] = 'No SFP'\n\n    for key,value in sfp.items():\n        #construct interface from fpc, pic, port and sfp description\n        if '10G' in value[1][1]:\n            type = 'xe-'\n        else:\n            type = 'ge-'\n        fpc = value[4][1].replace('FPC ', '')\n        pic = value[2][1].replace('PIC ', '')\n        port = key.replace('Xcvr ', '')\n\n        #match chassis hardware description to netbox tags\n        try:\n            if value[1][1] == 'SFP+-10G-LR' or value[1][1] == 'SFP-LX10' or value[1][1] == 'QSFP+-40G-LR4' or value[1][1] == 'XFP-10G-LR':\n                results[type+fpc+'/'+pic+'/'+port]['type']='SMF'\n            elif value[1][1] == 'SFP+-10G-SR' or value[1][1] == 'SFP-SX':\n                results[type + fpc + '/' + pic + '/' + port]['type'] = 'MMF'\n            else:\n                results[type + fpc + '/' + pic + '/' + port]['type'] = 'copper'\n        except:\n            pass\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_ipv4_public_routes","title":"<code>juniper_get_mx_ipv4_public_routes(fqdn, site, username, password)</code>","text":"<p>Return public IPv4 networks configured at a specific SVC site on an MX device.</p> <p>The function selects a site-specific route parser (from built-in YML models) to get public networks and then maps each route to the interface description from the MX logical table.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_ipv4_public_routes--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the MX device. site : str     Site identifier used to select the correct route parser (e.g. 'at1', 'ch3', 'ny5', etc.). username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_ipv4_public_routes--returns","title":"Returns","text":"<p>dict[str, str]     Mapping of route (CIDR string) to the interface description (value).</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_mx_ipv4_public_routes(fqdn,site,username,password):\n    \"\"\"Return public IPv4 networks configured at a specific SVC site on an MX device.\n\n    The function selects a site-specific route parser (from built-in YML models) to get public\n    networks and then maps each route to the interface description from the MX logical table.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the MX device.\n    site : str\n        Site identifier used to select the correct route parser (e.g. 'at1', 'ch3', 'ny5', etc.).\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[str, str]\n        Mapping of route (CIDR string) to the interface description (value).\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22', timeout=300) as dev:\n        if site =='at1':\n            routes = br1svcat1corpequinixcom(dev)\n        elif site =='ch3':\n            routes = br1svcch3corpequinixcom(dev)\n        elif site =='da6':\n            routes = br1svcda6corpequinixcom(dev)\n        elif site =='dc6':\n            routes = br1svcdc6corpequinixcom(dev)\n        elif site =='la3':\n            routes = br1svcla3corpequinixcom(dev)\n        elif site =='mi1':\n            routes = br1svcmi1corpequinixcom(dev)\n        elif site =='ny5':\n            routes = br1svcny5corpequinixcom(dev)\n        elif site =='se3':\n            routes = br1svcse3corpequinixcom(dev)\n        elif site =='sv5':\n            routes = br1svcsv5corpequinixcom(dev)\n        elif site =='am3':\n            routes = svcbr1am3corpeuequinixcom(dev)\n        elif site =='fr4':\n            routes = svcbr1fr4corpeuequinixcom(dev)\n        elif site =='ld5':\n            routes = svcbr1ld5corpeuequinixcom(dev)\n        elif site =='hk2':\n            routes = br1svchk2apequinixcom(dev)\n        elif site =='os1':\n            routes = br1svcos1apequinixcom(dev)\n        elif site =='sg2':\n            routes = br1svcsg2apequinixcom(dev)\n        elif site =='sy4':\n            routes = br1svcsy4apequinixcom(dev)\n        elif site =='ty4':\n            routes = br1svcty4apequinixcom(dev)\n        elif site =='tr2':\n            routes = br1svctr2corpequinixcom(dev)\n        routes.get()\n\n        ports = MXLogicalTable(dev)\n        ports.get()\n\n    # create a dictionary of routes and descriptions (based on interface description)\n    results = {}\n    for key, value in routes.items():\n        if value[3][1] is None and value[4][1] is None:\n            if value[2][1] in ports:\n                results.update({key: ports[value[2][1]]['description']})\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_version","title":"<code>juniper_get_mx_version(fqdn, username, password)</code>","text":"<p>Return the software version string reported by a Juniper MX device.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_version--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the MX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_mx_version--returns","title":"Returns","text":"<p>str     Version string as returned by the MX device model.</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_mx_version(fqdn, username, password):\n    \"\"\"Return the software version string reported by a Juniper MX device.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the MX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    str\n        Version string as returned by the MX device model.\n    \"\"\"\n    dev = Device(host=fqdn, user=username, password=password, port='22',timeout=300).open()\n    mx_version = MXVersion(dev)\n    mx_version.get()\n\n    results=mx_version[0].version\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_interfaces","title":"<code>juniper_get_qfx_interfaces(fqdn, username, password)</code>","text":"<p>Return QFX interface metadata including description, speed, and fiber/copper type.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_interfaces--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the QFX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_interfaces--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of interface name to a dict containing:     - 'description' (str)     - 'speed' (str) e.g. '1Gbps', '10Gbps' or 'None'     - 'type' (str) one of 'SMF', 'MMF', 'copper', or 'lag'</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_qfx_interfaces(fqdn, username, password):\n    \"\"\"Return QFX interface metadata including description, speed, and fiber/copper type.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the QFX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of interface name to a dict containing:\n        - 'description' (str)\n        - 'speed' (str) e.g. '1Gbps', '10Gbps' or 'None'\n        - 'type' (str) one of 'SMF', 'MMF', 'copper', or 'lag'\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22', timeout=300) as dev:\n        phy_port = QFXEXPhysicalTable(dev)\n        sfp_info = QFXEXChassisHardware(dev)\n        phy_port.get()\n        sfp_info.get()\n\n    # create a dictionary of interface names with another dictionary with port description, sfp type and speed\n    results = {}\n    for key, value in phy_port.items():\n        if value[0][1] == None:\n            results.update({key: {'description': ''}})\n        else:\n            results.update({key: {'description': value[0][1]}})\n        # change 1000mbps to 1Gbps to match Netbox tag\n        if value[1][1] == '1000mbps' or value[1][1] == '1000 Mbps':\n            results[key]['speed'] = '1Gbps'\n        elif value[1][1] == 'Auto':\n            results[key]['speed'] = '10Gbps'\n        elif value[1][1] == None:\n            results[key]['speed'] = 'None'\n        else:\n            results[key]['speed'] = value[1][1]\n\n        # for em interfaces set type to copper\n        if 'em' in key:\n            results[key]['type'] = 'copper'\n        elif 'ae' in key:\n            results[key]['type'] = 'lag'\n    for key, value in sfp_info.items():\n        # construct interface from fpc, pic, port and sfp description\n        if '10G' in value[1][1]:\n            type = 'xe-'\n        else:\n            type = 'ge-'\n        fpc = value[4][1].replace('FPC ', '')\n        pic = value[3][1].replace('PIC ', '')\n        port = key.replace('Xcvr ', '')\n\n        # match chassis hardware description to netbox tags\n        if int(port) &lt; 48:\n            try:\n                if value[1][1] == 'SFP+-10G-LR' or value[1][1] == 'SFP-LX10' or value[1][1] == 'QSFP+-40G-LR4':\n                    results[type+fpc+'/'+pic+'/'+port]['type'] = 'SMF'\n                elif value[1][1] == 'SFP+-10G-SR' or value[1][1] == 'SFP-SX':\n                    results[type + fpc + '/' + pic + '/' + port]['type'] = 'MMF'\n                else:\n                    results[type + fpc + '/' + pic + '/' + port]['type'] = 'copper'\n            except:\n                pass\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_version","title":"<code>juniper_get_qfx_version(fqdn, username, password)</code>","text":"<p>Return the software version string reported by a Juniper QFX device.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_version--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the QFX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_version--returns","title":"Returns","text":"<p>str     Version string as returned by the QFX device model.</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_qfx_version(fqdn, username, password):\n    \"\"\"Return the software version string reported by a Juniper QFX device.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the QFX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    str\n        Version string as returned by the QFX device model.\n    \"\"\"\n    dev = Device(host=fqdn, user=username, password=password, port='22',timeout=300).open()\n    qfx_version = QFXVersion(dev)\n    qfx_version.get()\n\n    results=qfx_version[0].version\n    return results\n</code></pre>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_vlans_dictionary","title":"<code>juniper_get_qfx_vlans_dictionary(fqdn, username, password)</code>","text":"<p>Return a mapping of VLAN IDs to configured VLAN names on a QFX device.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_vlans_dictionary--parameters","title":"Parameters","text":"<p>fqdn : str     Hostname or IP of the QFX device. username : str     Username for device authentication. password : str     Password for device authentication.</p>"},{"location":"juniper/#svc_juniper_lib.juniper.juniper_get_qfx_vlans_dictionary--returns","title":"Returns","text":"<p>dict[int, str]     Mapping of VLAN tag (int) to VLAN name (str).</p> Source code in <code>packages/svc_juniper_lib/src/svc_juniper_lib/juniper.py</code> <pre><code>def juniper_get_qfx_vlans_dictionary(fqdn, username, password):\n    \"\"\"Return a mapping of VLAN IDs to configured VLAN names on a QFX device.\n\n    Parameters\n    ----------\n    fqdn : str\n        Hostname or IP of the QFX device.\n    username : str\n        Username for device authentication.\n    password : str\n        Password for device authentication.\n\n    Returns\n    -------\n    dict[int, str]\n        Mapping of VLAN tag (int) to VLAN name (str).\n    \"\"\"\n    # Netconf session to a juniper device\n    with Device(host=fqdn, user=username, password=password, port='22', timeout=300) as dev:\n        vlans = QFXVlanTable(dev)\n        vlans.get()\n\n    # create a dictionary of vlan tags (key) and vlan names (value)\n    results = {}\n\n    for key, value in vlans.items():\n        results.update({int(key): value[0][1]})\n\n    return results\n</code></pre>"},{"location":"netbox/","title":"Netbox Library","text":""},{"location":"netbox/#svc_netbox_lib.netbox","title":"<code>svc_netbox_lib.netbox</code>","text":""},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_interface","title":"<code>netbox_delete_interface(token, id)</code>","text":"<p>Delete an interface from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_interface--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. id : int     NetBox interface id to delete.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_interface--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_delete_interface(token, id):\n    \"\"\"Delete an interface from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    id : int\n        NetBox interface id to delete.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.delete('http://netbox.solutionvalidation.center/api/dcim/interfaces/'+ str(id)+ '/', headers=myheaders)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_ip_address","title":"<code>netbox_delete_ip_address(token, ip_id)</code>","text":"<p>Delete an IP address from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_ip_address--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. ip_id : int     NetBox IP address object id to delete.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_ip_address--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_delete_ip_address(token, ip_id):\n    \"\"\"Delete an IP address from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    ip_id : int\n        NetBox IP address object id to delete.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.delete('http://netbox.solutionvalidation.center/api/ipam/ip-addresses/'+ str(ip_id)+ '/', headers=myheaders)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vlan","title":"<code>netbox_delete_vlan(token, id)</code>","text":"<p>Delete a VLAN object from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vlan--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. id : int     NetBox VLAN object id to delete.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vlan--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_delete_vlan(token, id):\n    \"\"\"Delete a VLAN object from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    id : int\n        NetBox VLAN object id to delete.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token, 'Content-Type': 'application/json'}\n    data = requests.delete('http://netbox.solutionvalidation.center/api/ipam/vlans/'+ str(id)+ '/', headers=myheaders)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vrf","title":"<code>netbox_delete_vrf(token, vrf_id)</code>","text":"<p>Delete a VRF from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vrf--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. vrf_id : int     NetBox VRF object id to delete.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_delete_vrf--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_delete_vrf(token, vrf_id):\n    \"\"\"Delete a VRF from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    vrf_id : int\n        NetBox VRF object id to delete.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.delete('http://netbox.solutionvalidation.center/api/ipam/vrfs/'+ str(vrf_id)+ '/', headers=myheaders)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_device_platform","title":"<code>netbox_get_device_platform(token, device_id)</code>","text":"<p>Get the current platform name and upgrade flag for a device in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_device_platform--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. device_id : int     NetBox device id.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_device_platform--returns","title":"Returns","text":"<p>tuple[str, Any]     (platform_name, upgrade_flag) where platform_name is the platform name string or 'none'     and upgrade_flag is the device's custom_fields['upgrade'] value or None.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_device_platform(token, device_id):\n    \"\"\"Get the current platform name and upgrade flag for a device in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    device_id : int\n        NetBox device id.\n\n    Returns\n    -------\n    tuple[str, Any]\n        (platform_name, upgrade_flag) where platform_name is the platform name string or 'none'\n        and upgrade_flag is the device's custom_fields['upgrade'] value or None.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.get('http://netbox.solutionvalidation.center/api/dcim/devices/'+ str(device_id)+'/', headers=myheaders)\n    data = data.json()\n    if data['platform'] is not None:\n        platform = data['platform']['name']\n        upgrade = data['custom_fields']['upgrade']\n    else:\n        platform = 'none'\n        upgrade = None\n    return platform, upgrade\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_fqdn","title":"<code>netbox_get_fqdn(token, site, device)</code>","text":"<p>Query NetBox for a device and return its FQDN/name.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_fqdn--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. site : str     Site identifier to filter devices by. device : str     Search string for the device (e.g. 'br1', 'csw1').</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_fqdn--returns","title":"Returns","text":"<p>str     Device FQDN/name if found, otherwise the string 'none'.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_fqdn(token, site, device):\n    \"\"\"Query NetBox for a device and return its FQDN/name.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    site : str\n        Site identifier to filter devices by.\n    device : str\n        Search string for the device (e.g. 'br1', 'csw1').\n\n    Returns\n    -------\n    str\n        Device FQDN/name if found, otherwise the string 'none'.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token}\n    parameters = {'site': site, 'q': device}\n    data = requests.get('http://netbox.solutionvalidation.center/api/dcim/devices/', headers=myheaders, params=parameters)\n    data = data.json()\n    try:\n        fqdn = data['results'][0]['name']\n    except:\n        fqdn = 'none'\n    return fqdn\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_id","title":"<code>netbox_get_id(token, location, device)</code>","text":"<p>Return the NetBox device id for a device matching location and name.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_id--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. location : str     Site/location code to filter devices by. device : str     Search string for the device.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_id--returns","title":"Returns","text":"<p>int     NetBox device id (raises if no results are found).</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_id(token, location, device):\n    \"\"\"Return the NetBox device id for a device matching location and name.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    location : str\n        Site/location code to filter devices by.\n    device : str\n        Search string for the device.\n\n    Returns\n    -------\n    int\n        NetBox device id (raises if no results are found).\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token}\n    parameters = {'q': device, 'site': location, 'tenant' : 'svc'}\n    data = requests.get('http://netbox.solutionvalidation.center/api/dcim/devices/', headers=myheaders, params=parameters)\n    data = data.json()\n    results = data['results'][0]['id']\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_interfaces","title":"<code>netbox_get_interfaces(token, id)</code>","text":"<p>Fetch interfaces for a NetBox device and return a structured mapping.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_interfaces--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. id : int     NetBox device id to list interfaces for.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_interfaces--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of interface name -&gt; dict containing:     - 'id' (int): NetBox interface id     - 'description' (str)     - 'type' (str): one of 'SMF', 'MMF', 'copper', 'lag', 'No SFP', etc.     - 'speed' (str): human-readable speed tag</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_interfaces(token, id):\n    \"\"\"Fetch interfaces for a NetBox device and return a structured mapping.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    id : int\n        NetBox device id to list interfaces for.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of interface name -&gt; dict containing:\n        - 'id' (int): NetBox interface id\n        - 'description' (str)\n        - 'type' (str): one of 'SMF', 'MMF', 'copper', 'lag', 'No SFP', etc.\n        - 'speed' (str): human-readable speed tag\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token}\n    parameters = {'q' : '', 'device_id' : id, 'limit' : 100000}\n    data = requests.get('http://netbox.solutionvalidation.center/api/dcim/interfaces/', headers=myheaders, params=parameters)\n    data = data.json()\n    results = {}\n    for i in range(len(data['results'])):\n        if 'vcp' not in data['results'][i]['name'] and 'member' not in data['results'][i]['name'] and 'vlan' not in data['results'][i]['name']:\n            results.update({data['results'][i]['name']:{'id':data['results'][i]['id'],'description':data['results'][i]['description'], 'type':'', 'speed':''}})\n        for x in data['results'][i]['tags']:\n            if x == 'SMF':\n                results[data['results'][i]['name']]['type']='SMF'\n            elif x == 'MMF':\n                results[data['results'][i]['name']]['type'] = 'MMF'\n            elif x == 'copper':\n                results[data['results'][i]['name']]['type'] = 'copper'\n            elif x == 'lag':\n                results[data['results'][i]['name']]['type'] = 'lag'\n            elif x == 'No SFP':\n                results[data['results'][i]['name']]['type'] = 'No SFP'\n            elif x == '100mbps':\n                results[data['results'][i]['name']]['speed'] = '100mbps'\n            elif x == '100 Mbps':\n                results[data['results'][i]['name']]['speed'] = '100 Mbps'\n            elif x == '1Gbps':\n                results[data['results'][i]['name']]['speed'] = '1Gbps'\n            elif x == '10Gbps':\n                results[data['results'][i]['name']]['speed'] = '10Gbps'\n            elif x == '20Gbps':\n                results[data['results'][i]['name']]['speed'] = '20Gbps'\n            elif x == '30Gbps':\n                results[data['results'][i]['name']]['speed'] = '30Gbps'\n            elif x == '40Gbps':\n                results[data['results'][i]['name']]['speed'] = '40Gbps'\n            elif x == 'Unspecified':\n                results[data['results'][i]['name']]['speed'] = 'Unspecified'\n            elif x == 'None':\n                results[data['results'][i]['name']]['speed'] = 'None'\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_prefix","title":"<code>netbox_get_ipv4_public_prefix(token, site)</code>","text":"<p>Return the IPv4 public prefix role entry for a given site.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_prefix--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. site : str     Site identifier (used to construct the role filter: '-ipv4-public-ip-space')."},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_prefix--returns","title":"Returns","text":"<p>str     The prefix string (e.g. '64.191.201.0/24'), or an empty string if none found.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_ipv4_public_prefix(token, site):\n    \"\"\"Return the IPv4 public prefix role entry for a given site.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    site : str\n        Site identifier (used to construct the role filter: '&lt;site&gt;-ipv4-public-ip-space').\n\n    Returns\n    -------\n    str\n        The prefix string (e.g. '64.191.201.0/24'), or an empty string if none found.\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token}\n    parameters = {'q' : '', 'role': site+'-ipv4-public-ip-space'}\n    data = requests.get('http://netbox.solutionvalidation.center/api/ipam/prefixes/', headers=myheaders, params=parameters)\n    data = data.json()\n    results = ''\n    for i in range(len(data['results'])):\n        results = data['results'][i]['prefix']\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_routes","title":"<code>netbox_get_ipv4_public_routes(token, site)</code>","text":"<p>Return IPv4 public addresses (children of the site's public prefix) from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_routes--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. site : str     Site identifier to locate the parent public prefix.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_ipv4_public_routes--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of address (CIDR string) -&gt; dict with keys 'id' and 'description'.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_ipv4_public_routes(token, site):\n    \"\"\"Return IPv4 public addresses (children of the site's public prefix) from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    site : str\n        Site identifier to locate the parent public prefix.\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of address (CIDR string) -&gt; dict with keys 'id' and 'description'.\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token}\n    parent_prefix = netbox_get_ipv4_public_prefix(token, site)\n    if parent_prefix == '':\n        parent_prefix = '1.1.1.0/30'\n    parameters = {'q' : '', 'parent': parent_prefix, 'limit' : 100000}\n    data = requests.get('http://netbox.solutionvalidation.center/api/ipam/ip-addresses/', headers=myheaders, params=parameters)\n    data = data.json()\n    results={}\n    for i in range(len(data['results'])):\n        results.update({data['results'][i]['address']:{'id':data['results'][i]['id'], 'description': data['results'][i]['description']}})\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_platforms","title":"<code>netbox_get_platforms(token)</code>","text":"<p>Return a list of platform names (software versions) from NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_platforms--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_platforms--returns","title":"Returns","text":"<p>list[str]     List of platform names as strings.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_platforms(token):\n    \"\"\"Return a list of platform names (software versions) from NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n\n    Returns\n    -------\n    list[str]\n        List of platform names as strings.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.get('http://netbox.solutionvalidation.center/api/dcim/platforms/', headers=myheaders)\n    data = data.json()\n    results = []\n    for i in range(len(data['results'])):\n        results.append(data['results'][i]['name'])\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_sites","title":"<code>netbox_get_sites()</code>","text":"<p>Return the list of supported SVC site identifiers.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_sites--returns","title":"Returns","text":"<p>list[str]     A list of site codes (e.g. 'ld5', 'da6', 'ny5', ...).</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_sites():\n    \"\"\"Return the list of supported SVC site identifiers.\n\n    Returns\n    -------\n    list[str]\n        A list of site codes (e.g. 'ld5', 'da6', 'ny5', ...).\n    \"\"\"\n    svc_locations = ['ld5', 'dx1', 'da6', 'dc6', 'la3', 'mi1', 'ny5', 'se3', 'sv5', 'am3', 'ch3', 'fr4', 'at1', 'hk2',\n                     'os1', 'sg2', 'sy4', 'ty4', 'tr2']\n    return svc_locations\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vlan_dictionary","title":"<code>netbox_get_vlan_dictionary(token, site, device)</code>","text":"<p>Return a mapping of VLAN tag to NetBox VLAN ID for a site and device filter.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vlan_dictionary--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. site : str     Site identifier to filter VLANs by. device : str     Search/filter term for VLANs (passed as 'q' to the API).</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vlan_dictionary--returns","title":"Returns","text":"<p>dict[int, int] or dict     Mapping of VLAN VID (int) -&gt; NetBox VLAN object id (int). If the request fails or no data is present,     returns {'none': 'none'}.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_vlan_dictionary(token, site, device):\n    \"\"\"Return a mapping of VLAN tag to NetBox VLAN ID for a site and device filter.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    site : str\n        Site identifier to filter VLANs by.\n    device : str\n        Search/filter term for VLANs (passed as 'q' to the API).\n\n    Returns\n    -------\n    dict[int, int] or dict\n        Mapping of VLAN VID (int) -&gt; NetBox VLAN object id (int). If the request fails or no data is present,\n        returns {'none': 'none'}.\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token}\n    parameters = {'q' : device, 'site': site, 'limit' : 100000}\n    data = requests.get('http://netbox.solutionvalidation.center/api/ipam/vlans/', headers=myheaders, params=parameters)\n    data = data.json()\n    results = {}\n    try:\n        for i in range(len(data['results'])):\n            results.update({data['results'][i]['vid'] : data['results'][i]['id']})\n    except:\n        results = {'none': 'none'}\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vrfs","title":"<code>netbox_get_vrfs(token, site)</code>","text":"<p>Return VRFs for a given site from NetBox with selected metadata.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vrfs--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. site : str     Site identifier to filter VRFs by (custom field 'Site').</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_get_vrfs--returns","title":"Returns","text":"<p>dict[str, dict]     Mapping of VRF name -&gt; dict with keys:     - 'id' : NetBox VRF id     - 'instance_type' : custom field 'type'     - 'route_distinguisher' : rd (string)     - 'instance_interface' : tags list     - 'site' : custom field 'Site'</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_get_vrfs(token, site):\n    \"\"\"Return VRFs for a given site from NetBox with selected metadata.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    site : str\n        Site identifier to filter VRFs by (custom field 'Site').\n\n    Returns\n    -------\n    dict[str, dict]\n        Mapping of VRF name -&gt; dict with keys:\n        - 'id' : NetBox VRF id\n        - 'instance_type' : custom field 'type'\n        - 'route_distinguisher' : rd (string)\n        - 'instance_interface' : tags list\n        - 'site' : custom field 'Site'\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token, 'Content-Type': 'application/json'}\n    parameters = {'q':'', 'cf_Site':site, 'limit' : 100000}\n    data = requests.get('http://netbox.solutionvalidation.center/api/ipam/vrfs/',headers=myheaders, params=parameters)\n    data = data.json()\n    results={}\n    for i in range(len(data['results'])):\n        results.update({data['results'][i]['name']:{'id':data['results'][i]['id'],'instance_type':data['results'][i]['custom_fields']['type'],\n                                                    'route_distinguisher':data['results'][i]['rd'],'instance_interface':data['results'][i]['tags'],\n                                                    'site':data['results'][i]['custom_fields']['Site']}})\n    return results\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_device_platform","title":"<code>netbox_patch_device_platform(token, device_id, payload)</code>","text":"<p>Patch/update the platform (software version) of a device in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_device_platform--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. device_id : int     NetBox device id. payload : dict     JSON payload with platform update fields.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_device_platform--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_patch_device_platform(token, device_id, payload):\n    \"\"\"Patch/update the platform (software version) of a device in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    device_id : int\n        NetBox device id.\n    payload : dict\n        JSON payload with platform update fields.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.patch('http://netbox.solutionvalidation.center/api/dcim/devices/'+ str(device_id)+'/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_interface","title":"<code>netbox_patch_interface(token, interface_id, payload)</code>","text":"<p>Patch/update an interface object in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_interface--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. interface_id : int     NetBox interface id to update. payload : dict     JSON payload with fields to update.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_interface--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_patch_interface(token, interface_id, payload):\n    \"\"\"Patch/update an interface object in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    interface_id : int\n        NetBox interface id to update.\n    payload : dict\n        JSON payload with fields to update.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.patch('http://netbox.solutionvalidation.center/api/dcim/interfaces/'+ str(interface_id)+'/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_ip_address","title":"<code>netbox_patch_ip_address(token, ip_id, payload)</code>","text":"<p>Patch/update an IP address object in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_ip_address--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. ip_id : int     NetBox IP address object id to update. payload : dict     JSON payload with fields to update (e.g. {'description': '...'}).</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_ip_address--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_patch_ip_address(token, ip_id, payload):\n    \"\"\"Patch/update an IP address object in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    ip_id : int\n        NetBox IP address object id to update.\n    payload : dict\n        JSON payload with fields to update (e.g. {'description': '...'}).\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.patch('http://netbox.solutionvalidation.center/api/ipam/ip-addresses/'+ str(ip_id)+'/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_vrf","title":"<code>netbox_patch_vrf(token, vrf_id, payload)</code>","text":"<p>Patch/update a VRF object in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_vrf--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. vrf_id : int     NetBox VRF object id to update. payload : dict     JSON payload with fields to update.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_patch_vrf--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_patch_vrf(token, vrf_id, payload):\n    \"\"\"Patch/update a VRF object in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    vrf_id : int\n        NetBox VRF object id to update.\n    payload : dict\n        JSON payload with fields to update.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.patch('http://netbox.solutionvalidation.center/api/ipam/vrfs/'+ str(vrf_id)+'/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_interface","title":"<code>netbox_post_interface(token, payload)</code>","text":"<p>Create one or more interfaces in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_interface--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. payload : dict     JSON payload for interface creation per NetBox API.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_interface--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_post_interface(token, payload):\n    \"\"\"Create one or more interfaces in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    payload : dict\n        JSON payload for interface creation per NetBox API.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.post('http://netbox.solutionvalidation.center/api/dcim/interfaces/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_ip_address","title":"<code>netbox_post_ip_address(token, payload)</code>","text":"<p>Create a new IP address in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_ip_address--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. payload : dict     JSON payload for IP creation (e.g. {'address': 'x.x.x.x/yy', 'description': '...', 'vrf': {...}}).</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_ip_address--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_post_ip_address(token, payload):\n    \"\"\"Create a new IP address in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    payload : dict\n        JSON payload for IP creation (e.g. {'address': 'x.x.x.x/yy', 'description': '...', 'vrf': {...}}).\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.post('http://netbox.solutionvalidation.center/api/ipam/ip-addresses/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_platform","title":"<code>netbox_post_platform(token, payload)</code>","text":"<p>Create a new platform (software version) in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_platform--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. payload : dict     JSON payload for platform creation (e.g. {'name': ..., 'slug': ...}).</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_platform--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_post_platform(token, payload):\n    \"\"\"Create a new platform (software version) in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    payload : dict\n        JSON payload for platform creation (e.g. {'name': ..., 'slug': ...}).\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.post('http://netbox.solutionvalidation.center/api/dcim/platforms/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vlan","title":"<code>netbox_post_vlan(token, payload)</code>","text":"<p>Create a VLAN in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vlan--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. payload : dict     JSON payload for VLAN creation following NetBox API schema.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vlan--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_post_vlan(token, payload):\n    \"\"\"Create a VLAN in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    payload : dict\n        JSON payload for VLAN creation following NetBox API schema.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization' : 'Token '+ token, 'Content-Type': 'application/json'}\n    data = requests.post('http://netbox.solutionvalidation.center/api/ipam/vlans/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vrf","title":"<code>netbox_post_vrf(token, payload)</code>","text":"<p>Create a new VRF in NetBox.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vrf--parameters","title":"Parameters","text":"<p>token : str     NetBox API token for authentication. payload : dict     JSON payload for VRF creation per NetBox API.</p>"},{"location":"netbox/#svc_netbox_lib.netbox.netbox_post_vrf--returns","title":"Returns","text":"<p>int     HTTP status code returned by the NetBox API.</p> Source code in <code>packages/svc_netbox_lib/src/svc_netbox_lib/netbox.py</code> <pre><code>def netbox_post_vrf(token, payload):\n    \"\"\"Create a new VRF in NetBox.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token for authentication.\n    payload : dict\n        JSON payload for VRF creation per NetBox API.\n\n    Returns\n    -------\n    int\n        HTTP status code returned by the NetBox API.\n    \"\"\"\n    myheaders = {'Authorization': 'Token ' + token, 'Content-Type': 'application/json'}\n    data = requests.post('http://netbox.solutionvalidation.center/api/ipam/vrfs/', headers=myheaders, json=payload)\n    return data.status_code\n</code></pre>"},{"location":"synchronize/","title":"Synchronize Library","text":""},{"location":"synchronize/#svc_synchronize_lib.synchronize","title":"<code>svc_synchronize_lib.synchronize</code>","text":""},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_interfaces","title":"<code>sync_ex_interfaces(token, site, username, password)</code>","text":"<p>Synchronize EX device interfaces with NetBox.</p> <p>This function: - Retrieves EX interface and SFP data from the device. - Retrieves NetBox interfaces for the EX device. - Adds missing interfaces to NetBox. - Updates tags (speed/type) and descriptions when they differ. - Deletes NetBox interfaces that no longer exist on the EX.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_interfaces--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_interfaces--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_ex_interfaces(token, site, username, password):\n    \"\"\"Synchronize EX device interfaces with NetBox.\n\n    This function:\n    - Retrieves EX interface and SFP data from the device.\n    - Retrieves NetBox interfaces for the EX device.\n    - Adds missing interfaces to NetBox.\n    - Updates tags (speed/type) and descriptions when they differ.\n    - Deletes NetBox interfaces that no longer exist on the EX.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get ex interface information from Juniper EX\n    fqdn = netbox.netbox_get_fqdn(token, site, 'ls1')\n    juniper_ex_dictionary = juniper.juniper_get_ex_interfaces(fqdn, username, password)\n\n    # get ex interface information from Netbox\n    device_id = netbox.netbox_get_id(token, site, 'ls1')\n    netbox_ex_dictionary = netbox.netbox_get_interfaces(token, device_id)\n\n    for key, value in juniper_ex_dictionary.items():\n        # check for interfaces found on Juniper but not in Netbox\n        if key not in netbox_ex_dictionary:\n            if 'xe' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '10gbase-x-sfpp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ge' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '1000base-x-sfp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ae' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': 'lag', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n\n        # update any speed, type, description changes\n        elif (value['speed'] != netbox_ex_dictionary[key]['speed'] or\n              value['type'] != netbox_ex_dictionary[key]['type']):\n            payload = {'tags': [value['speed'], value['type']]}\n            netbox.netbox_patch_interface(token, netbox_ex_dictionary[key]['id'], payload)\n        elif value['description'] != netbox_ex_dictionary[key]['description']:\n            payload = {'description': value['description']}\n            netbox.netbox_patch_interface(token, netbox_ex_dictionary[key]['id'], payload)\n\n    # remove any ex interfaces from Netbox that no longer exist on the ex switch\n    for key, value in netbox_ex_dictionary.items():\n        if key not in juniper_ex_dictionary:\n            netbox.netbox_delete_interface(token, value['id'])\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_platform_version","title":"<code>sync_ex_platform_version(token, site, username, password)</code>","text":"<p>Ensure the NetBox platform entry and device platform match the Juniper EX software version.</p> <p>This function: - Detects EX model (EX3400 vs EX2200) and reads version accordingly. - Ensures the version exists in NetBox platforms (creates if missing). - Updates the device platform in NetBox if it does not match the device. - Clears any 'upgrade' custom field when versions match.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_platform_version--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_ex_platform_version--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_ex_platform_version(token, site, username, password):\n    \"\"\"Ensure the NetBox platform entry and device platform match the Juniper EX software version.\n\n    This function:\n    - Detects EX model (EX3400 vs EX2200) and reads version accordingly.\n    - Ensures the version exists in NetBox platforms (creates if missing).\n    - Updates the device platform in NetBox if it does not match the device.\n    - Clears any 'upgrade' custom field when versions match.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get ex corp ip address from Netbox\n    fqdn = netbox.netbox_get_fqdn(token, site, \"ls1\")\n\n    # get netbox device id\n    device_id = netbox.netbox_get_id(token, site, \"ls1\")\n\n    # get version from EX\n    # switch in TR2 is a ex3400\n    if 'tr2' in fqdn:\n        ex_version = juniper.juniper_get_ex3400_version(fqdn, username, password)\n    else:\n        ex_version = juniper.juniper_get_ex2200_version(fqdn, username, password)\n\n    # Get the current platform (software version) of the device according to Netbox\n    ex_platform_netbox, ex_platform_upgrade = netbox.netbox_get_device_platform(token, device_id)\n\n    # get all platform versions from Netbox\n    all_platforms = netbox.netbox_get_platforms(token)\n\n    # if version on ex switch not in Netbox, add it to Netbox platform table\n    if ex_version not in all_platforms:\n        slug_version = ex_version.replace('.', '-')\n        new_platform = {'name': ex_version, 'slug': slug_version}\n        netbox.netbox_post_platform(token, new_platform)\n\n    # update Netbox device with version currently on the juniper ex\n    if ex_version != ex_platform_netbox:\n        if ex_platform_upgrade == None:\n            payload = {'platform': {'name': ex_version}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n\n    # remove upgrade flag if versions match\n    elif ex_version == ex_platform_netbox:\n        if ex_platform_upgrade != None:\n            payload = {'custom_fields': {'upgrade': None}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_interfaces","title":"<code>sync_mx_interfaces(token, site, username, password)</code>","text":"<p>Synchronize MX device interfaces with NetBox.</p> <p>This function: - Retrieves MX interface and SFP data from the device. - Retrieves NetBox interfaces for the MX device. - Adds missing interfaces to NetBox. - Updates tags (speed/type) and descriptions when they differ. - Deletes NetBox interfaces that no longer exist on the MX (except management).</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_interfaces--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_interfaces--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_mx_interfaces(token, site, username, password):\n    \"\"\"Synchronize MX device interfaces with NetBox.\n\n    This function:\n    - Retrieves MX interface and SFP data from the device.\n    - Retrieves NetBox interfaces for the MX device.\n    - Adds missing interfaces to NetBox.\n    - Updates tags (speed/type) and descriptions when they differ.\n    - Deletes NetBox interfaces that no longer exist on the MX (except management).\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # determine MX ip address and device id\n    fqdn = netbox.netbox_get_fqdn(token, site, 'br1')\n    device_id = netbox.netbox_get_id(token, site, 'br1')\n\n    # get mx interface information from Juniper MX\n    juniper_mx_dictionary = juniper.juniper_get_mx_interfaces(fqdn, username, password)\n\n    # get mx interface information from Netbox\n    netbox_mx_dictionary = netbox.netbox_get_interfaces(token, device_id)\n\n    # add any missing mx ports to the mx device in Netbox\n    # update any speed, type, description changes\n    for key, value in juniper_mx_dictionary.items():\n        # add any missing mx ports to the mx device in Netbox\n        if key not in netbox_mx_dictionary:\n            if 'xe' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '10gbase-x-sfpp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ge' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '1000base-x-sfp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ae' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': 'lag', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n        # update any speed, type, description changes\n        elif value['speed'] != netbox_mx_dictionary[key]['speed'] or value['type'] != netbox_mx_dictionary[key]['type']:\n            payload = {'tags': [value['speed'], value['type']]}\n            netbox.netbox_patch_interface(token, netbox_mx_dictionary[key]['id'], payload)\n        elif value['description'] != netbox_mx_dictionary[key]['description']:\n            payload = {'description': value['description']}\n            netbox.netbox_patch_interface(token, netbox_mx_dictionary[key]['id'], payload)\n\n    # remove any mx interfaces from Netbox that no longer exist on the mx router\n    for key, value in netbox_mx_dictionary.items():\n        if key != 'MGMT':\n            if key not in juniper_mx_dictionary:\n                netbox.netbox_delete_interface(token, value['id'])\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_netbox_public_ipv4_routes","title":"<code>sync_mx_netbox_public_ipv4_routes(token, site, username, password)</code>","text":"<p>Synchronize public IPv4 routes between an MX device and NetBox for a site.</p> <p>This function: - Retrieves public route prefixes configured on the MX (site-specific YML models). - Expands each network into individual addresses and maps them to interface descriptions. - Patches NetBox IP objects where descriptions changed. - Creates NetBox IP objects that are present on the device but missing in NetBox. - Deletes NetBox IP objects that are no longer present on the device.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_netbox_public_ipv4_routes--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_netbox_public_ipv4_routes--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_mx_netbox_public_ipv4_routes(token, site, username, password):\n    \"\"\"Synchronize public IPv4 routes between an MX device and NetBox for a site.\n\n    This function:\n    - Retrieves public route prefixes configured on the MX (site-specific YML models).\n    - Expands each network into individual addresses and maps them to interface descriptions.\n    - Patches NetBox IP objects where descriptions changed.\n    - Creates NetBox IP objects that are present on the device but missing in NetBox.\n    - Deletes NetBox IP objects that are no longer present on the device.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get public ipv4 routes from juniper\n    fqdn = netbox.netbox_get_fqdn(token, site, 'br1')\n    juniper_routes = juniper.juniper_get_mx_ipv4_public_routes(fqdn, site, username, password)\n\n    # get public ipv4 routes from Netbox\n    netbox_routes = netbox.netbox_get_ipv4_public_routes(token, site)\n\n    # create a dictionary of all ips in use with descriptions\n    # EXAMPLE: {'64.191.201.2/31': 'SVC: THOUSANDEYES AWS IPV4', '64.191.201.3/31': 'SVC: THOUSANDEYES AWS IPV4'}\n    juniper_routes_expanded = {}\n    for key, value in juniper_routes.items():\n        mask = key[-3:]\n        for addr in ipaddress.ip_network(key):\n            juniper_routes_expanded.update({str(addr) + mask: value})\n\n    # Patch routes that need to be updated\n    # add new routes\n    for key, value in juniper_routes_expanded.items():\n        if key in netbox_routes and value != netbox_routes[key]['description'] and value is not None:\n            payload = {'address': key, 'description': value}\n            netbox.netbox_patch_ip_address(token, key, payload)\n        elif key not in netbox_routes:\n            if value is None:\n                payload = {'address': key, 'description': '', 'vrf': {'name': site.upper() + ' RI-VRF-Internet-2'}}\n                netbox.netbox_post_ip_address(token, payload)\n            else:\n                payload = {'address': key, 'description': value, 'vrf': {'name': site.upper() + ' RI-VRF-Internet-2'}}\n                netbox.netbox_post_ip_address(token, payload)\n\n    # delete routes that are no longer in the mx\n    for key, value in netbox_routes.items():\n        if key not in juniper_routes_expanded:\n            netbox.netbox_delete_ip_address(token, value['id'])\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_platform_version","title":"<code>sync_mx_platform_version(token, site, username, password)</code>","text":"<p>Ensure the NetBox platform entry and device platform match the Juniper MX software version.</p> <p>This function: - Reads the software version from the MX. - Ensures the version exists in NetBox platforms (creates it if missing). - Updates the device platform in NetBox if it does not match the MX. - Clears any 'upgrade' custom field if the versions already match.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_platform_version--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_platform_version--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_mx_platform_version(token, site, username, password):\n    \"\"\"Ensure the NetBox platform entry and device platform match the Juniper MX software version.\n\n    This function:\n    - Reads the software version from the MX.\n    - Ensures the version exists in NetBox platforms (creates it if missing).\n    - Updates the device platform in NetBox if it does not match the MX.\n    - Clears any 'upgrade' custom field if the versions already match.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get mx corp ip address from Netbox\n    fqdn = netbox.netbox_get_fqdn(token, site, 'br1')\n\n    # get netbox device id\n    device_id = netbox.netbox_get_id(token, site, 'br1')\n\n    # get version from MX\n    mx_version = juniper.juniper_get_mx_version(fqdn, username, password)\n\n    # Get the current platform (software version) of the device according to Netbox\n    mx_platform_netbox, mx_platform_upgrade = netbox.netbox_get_device_platform(token, device_id)\n\n    # get all platform versions from Netbox\n    all_platforms = netbox.netbox_get_platforms(token)\n\n    # add version to Netbox if not in Netbox\n    if mx_version not in all_platforms:\n        slug_version = mx_version.replace('.', '-')\n        new_platform = {'name': mx_version, 'slug': slug_version}\n        netbox.netbox_post_platform(token, new_platform)\n\n    # change version in Netbox to match MX\n    if mx_version != mx_platform_netbox:\n        if mx_platform_upgrade == None:\n            payload = {'platform': {'name': mx_version}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n\n    # remove upgrade status since versions match\n    elif mx_version == mx_platform_netbox:\n        if mx_platform_upgrade != None:\n            payload = {'custom_fields': {'upgrade': None}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_qfx_netbox_vlans","title":"<code>sync_mx_qfx_netbox_vlans(token, site, username, password)</code>","text":"<p>Synchronize VLANs between Juniper QFX/MX devices and NetBox for a site.</p> <p>This function: - Queries the QFX for VLANs and the MX for subinterface VLANs. - Queries NetBox for VLANs keyed to the same site and device filters. - Creates NetBox VLAN objects for VLANs present on the devices but missing in NetBox. - Deletes NetBox VLAN objects that no longer exist on the devices.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_qfx_netbox_vlans--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier (e.g. 'ch3', 'ny5'). username : str     Username for Juniper device authentication. password : str     Password for Juniper device authentication.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_mx_qfx_netbox_vlans--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_mx_qfx_netbox_vlans(token, site, username, password):\n    \"\"\"Synchronize VLANs between Juniper QFX/MX devices and NetBox for a site.\n\n    This function:\n    - Queries the QFX for VLANs and the MX for subinterface VLANs.\n    - Queries NetBox for VLANs keyed to the same site and device filters.\n    - Creates NetBox VLAN objects for VLANs present on the devices but missing in NetBox.\n    - Deletes NetBox VLAN objects that no longer exist on the devices.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier (e.g. 'ch3', 'ny5').\n    username : str\n        Username for Juniper device authentication.\n    password : str\n        Password for Juniper device authentication.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get qfx vlan information from Juniper QFX\n    fqdn = netbox.netbox_get_fqdn(token, site, 'csw1')\n    juniper_qfx_dictionary = juniper.juniper_get_qfx_vlans_dictionary(fqdn, username, password)\n\n    # get mx subinterface information\n    fqdn = netbox.netbox_get_fqdn(token, site, 'br1')\n    juniper_mx_dictionary = juniper.juniper_get_mx_interface_vlans_dictionary(fqdn, username, password)\n\n    # get qfx vlan information from Netbox\n    netbox_qfx_vlans_dictionary = netbox.netbox_get_vlan_dictionary(token, site, 'qfx')\n\n    # get mx vlan information from Netbox\n    netbox_mx_vlans_dictionary = netbox.netbox_get_vlan_dictionary(token, site, 'mx')\n\n    # add new qfx vlans to netbox\n    for key, value in juniper_qfx_dictionary.items():\n        if key not in netbox_qfx_vlans_dictionary:\n            payload = {'site': {'name': site.upper()}, 'vid': key, 'name': value, 'description': 'qfx'}\n            netbox.netbox_post_vlan(token, payload)\n\n    # remove qfx netbox vlans that no longer appear on the qfx switch\n    for key, value in netbox_qfx_vlans_dictionary.items():\n        if key not in juniper_qfx_dictionary:\n            netbox.netbox_delete_vlan(token, value)\n\n    # add new mx vlans to netbox\n    for key, value in juniper_mx_dictionary.items():\n        if key not in netbox_mx_vlans_dictionary:\n            payload = {'site': {'name': site.upper()}, 'vid': key, 'name': value, 'description': 'mx'}\n            netbox.netbox_post_vlan(token, payload)\n\n    # remove mx netbox vlans that no longer appear on the mx switch\n    for key, value in netbox_mx_vlans_dictionary.items():\n        if key not in juniper_mx_dictionary:\n            netbox.netbox_delete_vlan(token, value)\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_netbox_mx_vrfs","title":"<code>sync_netbox_mx_vrfs(token, site, username, password)</code>","text":"<p>Synchronize Juniper MX routing-instances with NetBox VRFs for a site.</p> <p>This function: - Retrieves routing-instances from the MX and VRFs from NetBox. - Creates missing VRFs in NetBox based on MX routing-instances. - Updates VRF attributes (RD, type, tags/instance interfaces, site) when they differ. - Deletes VRFs from NetBox that no longer exist on the MX.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_netbox_mx_vrfs--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_netbox_mx_vrfs--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_netbox_mx_vrfs(token, site, username, password):\n    \"\"\"Synchronize Juniper MX routing-instances with NetBox VRFs for a site.\n\n    This function:\n    - Retrieves routing-instances from the MX and VRFs from NetBox.\n    - Creates missing VRFs in NetBox based on MX routing-instances.\n    - Updates VRF attributes (RD, type, tags/instance interfaces, site) when they differ.\n    - Deletes VRFs from NetBox that no longer exist on the MX.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get routing-instances from Juniper MX\n    fqdn = netbox.netbox_get_fqdn(token, site, 'br1')\n    juniper_instances = juniper.juniper_get_instance(fqdn, site, username, password)\n\n    # get vrfs from Netbox\n    netbox_vrfs = netbox.netbox_get_vrfs(token, site)\n\n    # identify missing vrfs and vrfs that need corrections\n    for key, value in juniper_instances.items():\n        interface_list = []\n        if value['instance_interface'] == None:\n            pass\n        elif isinstance(value['instance_interface'], list):\n            interface_list = value['instance_interface']\n        else:\n            interface_list = [value['instance_interface']]\n\n        if key not in netbox_vrfs:\n            payload = {'name': key, 'rd': value['route_distinguisher'], 'tags': interface_list,\n                       'custom_fields': {'Site': site, 'type': value['instance_type']}}\n            netbox.netbox_post_vrf(token, payload)\n\n        try:\n            if value['route_distinguisher'] != netbox_vrfs[key]['route_distinguisher']:\n                payload = {'name': key, 'rd': value['route_distinguisher']}\n                netbox.netbox_patch_vrf(token, netbox_vrfs[key]['id'], payload)\n        except:\n            pass\n        try:\n            if value['instance_type'] != netbox_vrfs[key]['instance_type']:\n                payload = {'name': key, 'custom_fields': {'type': value['instance_type']}}\n                netbox.netbox_patch_vrf(token, netbox_vrfs[key]['id'], payload)\n        except:\n            pass\n        try:\n            for i in interface_list:\n                if i not in netbox_vrfs[key]['instance_interface']:\n                    payload = {'name': key, 'tags': interface_list}\n                    netbox.netbox_patch_vrf(token, netbox_vrfs[key]['id'], payload)\n            for i in netbox_vrfs[key]['instance_interface']:\n                if i not in interface_list:\n                    payload = {'name': key, 'tags': interface_list}\n                    netbox.netbox_patch_vrf(token, netbox_vrfs[key]['id'], payload)\n        except:\n            pass\n        try:\n            if site != netbox_vrfs[key]['site']:\n                payload = {'name': key, 'custom_fields': {'Site': site}}\n                netbox.netbox_patch_vrf(token, netbox_vrfs[key]['id'], payload)\n        except:\n            pass\n\n    # find all vrfs that should be removed from Netbox\n    for key, value in netbox_vrfs.items():\n        if key not in juniper_instances:\n            netbox.netbox_delete_vrf(token, value['id'])\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_interfaces","title":"<code>sync_qfx_interfaces(token, site, username, password)</code>","text":"<p>Synchronize QFX device interfaces with NetBox.</p> <p>This function: - Retrieves interface metadata from a Juniper QFX (description, speed, type). - Retrieves interfaces for the corresponding NetBox device. - Adds interfaces missing in NetBox. - Updates tags (speed/type) and descriptions when they differ. - Deletes NetBox interfaces that no longer exist on the device.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_interfaces--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_interfaces--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_qfx_interfaces(token, site, username, password):\n    \"\"\"Synchronize QFX device interfaces with NetBox.\n\n    This function:\n    - Retrieves interface metadata from a Juniper QFX (description, speed, type).\n    - Retrieves interfaces for the corresponding NetBox device.\n    - Adds interfaces missing in NetBox.\n    - Updates tags (speed/type) and descriptions when they differ.\n    - Deletes NetBox interfaces that no longer exist on the device.\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get qfx interface information from Juniper QFX\n    fqdn = netbox.netbox_get_fqdn(token, site, 'csw1')\n    juniper_qfx_dictionary = juniper.juniper_get_qfx_interfaces(fqdn, username, password)\n\n    # get qfx interface information from Netbox\n    device_id = netbox.netbox_get_id(token, site, 'csw1')\n    netbox_qfx_dictionary = netbox.netbox_get_interfaces(token, device_id)\n\n    # add any missing qfx ports to the qfx device in Netbox\n    # update any speed, type, description changes\n    for key, value in juniper_qfx_dictionary.items():\n        # add any missing qfx ports to the qfx device in Netbox\n        if key not in netbox_qfx_dictionary:\n            if 'em' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '1000base-x-sfp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'xe' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '10gbase-x-sfpp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ge' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': '1000base-x-sfp', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n            elif 'ae' in key:\n                payload = {'device': {'id': device_id}, 'name': key, 'description': value['description'],\n                           'type': 'lag', 'tags': [value['speed'], value['type']]}\n                netbox.netbox_post_interface(token, payload)\n        # update any speed, type, description changes\n        elif (value['speed'] != netbox_qfx_dictionary[key]['speed'] or\n              value['type'] != netbox_qfx_dictionary[key]['type']):\n            payload = {'tags': [value['speed'], value['type']]}\n            netbox.netbox_patch_interface(token, netbox_qfx_dictionary[key]['id'], payload)\n        elif value['description'] != netbox_qfx_dictionary[key]['description']:\n            payload = {'description': value['description']}\n            netbox.netbox_patch_interface(token, netbox_qfx_dictionary[key]['id'], payload)\n\n    # remove any qfx interfaces from Netbox that no longer exist on the qfx switch\n    for key, value in netbox_qfx_dictionary.items():\n        if key not in juniper_qfx_dictionary:\n            netbox.netbox_delete_interface(token, value['id'])\n</code></pre>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_platform_version","title":"<code>sync_qfx_platform_version(token, site, username, password)</code>","text":"<p>Ensure the NetBox platform entry and device platform match the Juniper QFX software version.</p> <p>Behavior and parameters mirror sync_mx_platform_version but operate on the QFX device ('csw1').</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_platform_version--parameters","title":"Parameters","text":"<p>token : str     NetBox API token. site : str     Site identifier. username : str     Juniper device username. password : str     Juniper device password.</p>"},{"location":"synchronize/#svc_synchronize_lib.synchronize.sync_qfx_platform_version--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages/svc_synchronize_lib/src/svc_synchronize_lib/synchronize.py</code> <pre><code>def sync_qfx_platform_version(token, site, username, password):\n    \"\"\"Ensure the NetBox platform entry and device platform match the Juniper QFX software version.\n\n    Behavior and parameters mirror sync_mx_platform_version but operate on the QFX device ('csw1').\n\n    Parameters\n    ----------\n    token : str\n        NetBox API token.\n    site : str\n        Site identifier.\n    username : str\n        Juniper device username.\n    password : str\n        Juniper device password.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # get qfx corp ip address from Netbox\n    fqdn = netbox.netbox_get_fqdn(token, site, \"csw1\")\n\n    # get netbox device id\n    device_id = netbox.netbox_get_id(token, site, \"csw1\")\n\n    # get version from MX\n    qfx_version = juniper.juniper_get_qfx_version(fqdn, username, password)\n\n    # Get the current platform (software version) of the device according to Netbox\n    qfx_platform_netbox, qfx_platform_upgrade = netbox.netbox_get_device_platform(token, device_id)\n\n    # get all platform versions from Netbox\n    all_platforms = netbox.netbox_get_platforms(token)\n\n    # add any missing versions to Netbox\n    if qfx_version not in all_platforms:\n        slug_version = qfx_version.replace('.', '-')\n        new_platform = {'name': qfx_version, 'slug': slug_version}\n        netbox.netbox_post_platform(token, new_platform)\n\n    # find version mismatch\n    if qfx_version != qfx_platform_netbox:\n        if qfx_platform_upgrade == None:\n            payload = {'platform': {'name': qfx_version}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n\n    elif qfx_version == qfx_platform_netbox:\n        if qfx_platform_upgrade != None:\n            payload = {'custom_fields': {'upgrade': None}}\n            netbox.netbox_patch_device_platform(token, device_id, payload)\n</code></pre>"}]}